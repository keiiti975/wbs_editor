<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <title>wbs_editor</title>
    <link href="css/main.css" rel="stylesheet" />
    <script> var exports = {}; </script>
    <script type="text/javascript" src="../js/tree.js"></script>
    <script type="text/javascript" src="../js/window.js"></script>
    <script type="text/javascript" src="../js/element_selector.js"></script>
</head>

<body>
    <div id="editor_area" style="white-space: nowrap; overflow-x: scroll; padding-bottom: 15px; font-size: 0;">

    </div>

    <div id="footer_area">
        <a href="#" id="insert_task" class="btn-circle-stitch">+</a>
        <a href="#" id="delete_task" class="btn-circle-stitch">-</a>
    </div>

    <script>
        // for debugging
        const console = require('electron').remote.require('console');
        const electron = require('electron');

        const { ipcRenderer } = electron;

        const editor_area = document.getElementById('editor_area');
        const insert_task_btn = document.getElementById('insert_task');
        const delete_task_btn = document.getElementById('delete_task');

        let selected_elem = null;
        let tree = makeSampleTree();

        // select element
        function select_element() {
            selected_elem = getClickedElement(event, selected_elem);
        };

        // search greatest depth
        function search_max_depth(tree) {
            let max_depth = 0;
            let queue = [tree];
            let node = null;
            while (queue.length > 0) {
                node = queue.shift();
                if (node.depth > max_depth) {
                    max_depth = node.depth;
                }
                queue = queue.concat(node.childrenArray);
            }
            return max_depth;
        };

        // complement element with tree
        function complementEmptyElement(tree) {
            let max_depth = search_max_depth(tree);
            let queue = [tree];
            let node = null;
            while (queue.length > 0) {
                node = queue.shift();
                if (node.depth < max_depth && childrenArray.length == 0) {
                    insert_task2tree(tree, selected_elem, inputForm);
                }
                queue = queue.concat(node.childrenArray);
            }
        };

        // load editor from Task Tree
        function load_editor(tree) {
            init_editor_area();
            editor_area.insertAdjacentHTML("afterbegin", tree2html(tree));
            adjustElementHeight(tree);
        };

        // get clicked element
        editor_area.addEventListener('click', (event) => {
            select_element();
        });

        // request a input window
        insert_task_btn.addEventListener('click', (event) => {
            ipcRenderer.send('inputWindow:create');
        });

        // insert task
        ipcRenderer.on('inputForm:insert', (event, inputForm) => {
            insert_task2tree(tree, selected_elem, inputForm);
            load_editor(tree);
        });

        // delete task
        delete_task_btn.addEventListener('click', (event) => {
            load_editor(tree);
        });
    </script>
</body>

</html>